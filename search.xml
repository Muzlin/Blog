<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[实现一个jQuery的简单API的过程]]></title>
    <url>%2F2018%2F04%2F02%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAjQuery%E7%9A%84%E7%AE%80%E5%8D%95API%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[实现一个jQuery的简单API的过程 封装几个JavaScript提供的API 首先的思路是先封装几个原生js提供的api，然后在实验以哪种方式来调用比较合适 1234567891011121314151617// 获取当前节点的所有兄弟function getSiblings(node)&#123; // 获取父元素下的所有子元素 var children = node.parentNode.children // 声明结果存放的对象 var array = &#123; length: 0 &#125; // 遍历获取到的所有元素 for (let i = 0; i &lt; children.length; i++) &#123; if (children[i] !== this) &#123; array[array.length] = children[i] array.length += 1 &#125; &#125; return array&#125; 12345// 添加css样式function addClass (node,classes) &#123; // 遍历classes参数组然后添加到节点元素上 classes.forEach( (value) =&gt; node.classList.add(value) )&#125; 怎么将这两个函数关联起来 a. 以命名空间的方式关联 123456789101112131415161718192021222324252627282930window.leeDom = &#123;&#125;leeDom.getSiblings = function (node)&#123; // 获取父元素下的所有子元素 var allChildren = node.parentNode.children // 声明结果存放的对象 var array = &#123; length: 0&#125;// 遍历获取到的所有元素for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== this) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array&#125;leeDom.addClass = function (node,classes) &#123; // 遍历classes参数组然后添加到节点元素上 classes.forEach( (value) =&gt; node.classList.add(value) )&#125;e.g.&lt;div&gt; &lt;p id=x&gt; &lt;h1&gt;&lt;/h1&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;leeDom.getSiblings(x)leeDom.addClass(x) 这种方式的可以将N个方法丢在你最近的命名空间里面，因为在你自己的命名空间里所以不会对别人的库造成冲突 缺点就是每次使用的时候都要使用leeDom去点里面的方法，那能不能变成x.AddClass/x.GetSiblings这样的方式呢？ b. 更改Node的原型公有属性 123456789101112131415161718192021222324Node.prototype.getSiblings = function()&#123; var allChildren = this.parentNode.children var array = &#123; length: 0 &#125; for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== this) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array&#125;Node.prototype.addClass = function (classes) &#123; classes.forEach( (value) =&gt; this.classList.add(value) )&#125;e.g.&lt;div&gt; &lt;p id=x&gt; &lt;h1&gt;&lt;/h1&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;x.getSiblings()x.addClass() 这样我们做到了x.getSiblings这种发生调用但是这样容易造成冲突，因为你不能保证别人没有在Node的公有属性上添加你添加过的属性 c. 重新干一个Node，声明一个全局的对象Node2 1234567891011121314151617181920212223242526272829window.Node2 = function(node)&#123; return &#123; getSiblings:function()&#123; var allChildren = node.parentNode.children var array = &#123; length: 0 &#125; for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array &#125;, addClass:function (classes) &#123; classes.forEach( (value) =&gt; node.classList.add(value) ) &#125; &#125;&#125;e.g.&lt;div&gt; &lt;p id=x&gt; &lt;h1&gt;&lt;/h1&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;var xNode = Node2(x)xNode.getSiblings()xNode.addClass() d.考虑将Node2换个成jQuery 1234567891011121314151617181920212223242526272829window.jQuery = function(node)&#123; return &#123; getSiblings:function()&#123; var allChildren = node.parentNode.children var array = &#123; length: 0 &#125; for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== node) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array &#125;, addClass:function (classes) &#123; classes.forEach( (value) =&gt; node.classList.add(value) ) &#125; &#125;&#125;e.g.&lt;div&gt; &lt;p id=x&gt; &lt;h1&gt;&lt;/h1&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;var xNode = jQuery(x)xNode.getSiblings()xNode.addClass() e. 完善我们的简易jQuery 将传入参数变为节点或者选择器 12345678910111213141516171819window.jQuery = function(nodeOrSelector)&#123; let node if(typeof nodeOrSelector === 'string')&#123; node = doucument.querSelector(nodeOrSelector) &#125;else&#123; node = nodeOrSelector &#125; ... ...&#125;e.g.&lt;div&gt; &lt;p id=x&gt; &lt;h1&gt;&lt;/h1&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;var xNode = jQuery('div &gt; p')xNode.getSiblings()xNode.addClass() 操作单个或者多个节点 1234567891011121314151617181920212223242526272829303132333435363738 window.jQuery = function(nodeOrSelector)&#123; let nodes = &#123;&#125; if(typeof nodeOrSelector === 'string')&#123; let temps = doucument.querSelector(nodeOrSelector) for(let i = 0;i &lt; temps.length;i++)&#123; nodes[i] = temps[i] &#125; &#125;else if(nodeOrSelector instanceof Node)&#123; nodes&#123; 0: nodeOrSelector length: 1 &#125; &#125; // 只操作一个节点 nodes.getSiblings = function()&#123; if(nodes.length === 1)&#123; var allChildren = nodes[0].parentNode.children var array = &#123; length: 0 &#125; for (let i = 0; i &lt; allChildren.length; i++) &#123; if (allChildren[i] !== this) &#123; array[array.length] = allChildren[i] array.length += 1 &#125; &#125; return array &#125; &#125; nodes.addClass = function (classes) &#123; classes.forEach( (value) =&gt; &#123; for(let i = 0;i &lt; nodes.length; i++)&#123; nodes[i].classList.add(value) &#125; &#125; ) &#125;&#125; 添加其它方法 1234567891011121314151617window.jQuery = function(nodeOrSelector)&#123; ... ... nodes.text = function (text)&#123; if(text === 'undefined')&#123; var texts = [] for(let i = 0; i &lt; nodes.length; i++)&#123; text.pust = nodes[i].textContent &#125; return texts &#125;else&#123; for(let i = 0; i &lt; nodes.length; i++)&#123; nodes[i].textContent = text &#125; &#125; &#125;&#125; alias一下吧 window.$ = jQuery 完。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>jQuery javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Document Object Model 文档对象模型 DOM]]></title>
    <url>%2F2018%2F03%2F23%2FDocument-Object-Model-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-DOM%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JS a=3 是声明全局变量吗?]]></title>
    <url>%2F2018%2F03%2F22%2FJS-a-3-%E6%98%AF%E5%A3%B0%E6%98%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%90%97%2F</url>
    <content type="text"><![CDATA[1.作用域 2.变量提升]]></content>
  </entry>
  <entry>
    <title><![CDATA[疯狂打call JS Function 的硬核调用]]></title>
    <url>%2F2018%2F03%2F22%2F%E7%96%AF%E7%8B%82%E6%89%93call-JS-Function-%E7%9A%84%E7%A1%AC%E6%A0%B8%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[前端笔记-持续更新]]></title>
    <url>%2F2018%2F02%2F21%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[前端笔记HTML超文本标记语言(Hypertext Markup Language) html 只管元素的语义 e.g. &lt;p&gt;段落&lt;/p&gt; &lt;kbd&gt;键盘&lt;/kqb&gt; 不管元素的样式 以及是否为块级、行内 这些由css控制 除了&lt;span&gt;&lt;/span&gt; &lt;div&gt;&lt;/div&gt; 其它元素都有默认样式 div span 没有任务语义 所以你问html某个元素是什么样式 html：滚~]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Heap/Stack 堆/栈 的简单解释]]></title>
    <url>%2F2018%2F02%2F06%2FHeap-Stack-%E5%A0%86-%E6%A0%88-%E7%9A%84%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[今天看了阮一峰 阮老师的博客 汇编语言入门教程 汇编是看得一知半解，倒是对Heap(堆)Stack(栈)的理解有了更清晰的认识 内存模型 Heap程序运行的时候，操作系统会给它分配一段内存，用来存储程序和程序运行时产生的数据。 这段内存有起始地址和结束地址，比如0x1000-0x8000，起始地址小的是开始大的是结束 程序运行过程中，对于动态的内存占用请求(比如新建对象),系统会从预先分配好的内存中划出一部分，这一部分就是Heap(堆),它的特点是不会自动消失，必须手动释放，或者由垃圾回来机制来回收。 对堆而言，数据项位置没有固定的顺序。你可以以任何顺序插入和删除，因为他们没有“顶部”数据这一概念。 内存模型 Stack函数运行的时候，会在预分配的内存中临时占用一段区域，这段区域就是Stack(栈) 以下面的例子为例 1234int main() &#123; int a = 2; int b = 3;&#125; 系统执行main函数的时候，内存里面会建立一个帧(frame)，变量a和b会保存在这个帧里面，执行完成的时候该帧回收并且释放内部变量。 如果在main内部在调用一个其他函数 123456int main()&#123; int a = 2; int b = 3; int c = add(a,b); return c;&#125; 当函数执行到add函数的时候，会继续在Stack上建立一个帧，当add执行完的时候立即释放，继续执行整个函数执行完的时候这个Stack就全部释放。 系统首先创建的是的是main的帧，然后创建add的帧。执行后先释放add的帧，然后释放main的帧，所有对于栈来说是先进后出的。 总结当程序启动的时候，设置堆得大小但是可以扩展，它是无序的。当线程创建(程序执行)的时候，系统为每一个系统级的线程创建栈，栈属于线程当线程完成栈释放，栈是有序的先进后出。栈比堆要快，因为它存取模式使它可以轻松的分配和重新分配内存（指针/整型只是进行简单的递增或者递减运算），然而堆在分配和释放的时候有更多的复杂的 bookkeeping 参与。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>内存</tag>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF是什么?]]></title>
    <url>%2F2018%2F02%2F06%2FCSRF%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[跨站请求伪造（csrf）是一种劫持受信任用户向服务器发送非预期请求的攻击方式。例如，这些非预期请求可能在url后加入一些恶意的参数，从而达到攻击者的目的。 理解其他人通过csrf攻击盗用你的网站用户身份。 你这个网站用户所拥有的权限那他就都可以使用，比如用你的身份发消息、购买物品、转账等等。 原理A:用户的信任网站 B:危险网站 .成功登录A网站 这里浏览器会产生cookie .打开B网站 .B网站事先摸清了A网站的请求套路，比如转账的请求是:/zhuangzhang .此时打开B网站会有请求到A网站,并且携带了A网站的cookie .A的服务器会认为这是一个正常的处理，这样B就达到了模拟用户操作的目的 常见攻击类型 GET类型的csrf 某网站可以上传图片，然后小明上传了图片如下 &lt;img src=http://jirengu.com/csrf?xx=11 /&gt; 当用户访问到有此图片的页面时就完成了一次csrf攻击 POST类型的csrf 用户在登录他所信任的的网站之后又访问了危险网站 危险网站内有这样一段代码 1234&lt;form action=http://jirengu.com/csrf.php method=POST&gt; &lt;input type="text" name="xx" value="11" /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 访问此页面后 表单就会提交 此时就完成了一次post的csrf攻击 防御 验证 HTTP Referer 字段 http协议中，http头有一个字段叫 referer ，他记录了该请求的来源。 请求验证的时候，判断请求来源是否合法，不合法就拒绝并送他一句MMP.. 但是referer是可以篡改的，就断有些浏览器无法篡改对于某些注重隐私的组织来说这种方法也不实用。 添加token csrf的原理就是伪造用户的请求，那可以制造一种不能伪造或者很难伪造的请求。 我们可以再http请求中加一个随机产生的token，在服务器验证token 如果token不合法那就送他一句MMP吧 但是这种方法也有很大缺点，比如每个请求都需要携带token增加了开发成本 而且，通过referer也可以得到token值 完csrf的危害很大，但™️ 又难于防范，并没有很完美的解决方案，只有重视才能降低伤害。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML笔记]]></title>
    <url>%2F2018%2F02%2F05%2FHTML%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[HTML(HyperText Markup Language 超文本标记语言)是用来定义网页结构的一种语言。参考一些教程在这里汇总一下，加深记忆以及方便以后查阅。 结构 开始标签（Opening tag）：包括元素的名称（在本例中，p），包裹在开始和结束尖括号中。这表示元素开始或开始生效 - 在这种情况下，表示了一个段落的开头。 结束标签（Closing tag）：这与开始标记相同，除了它在元素名称之前包含正斜杠。这表示元素结束的位置 - 在这种情况下，表示了一个段落的结尾. 没有包含结束标记是一个常见的初学者错误，并可能导致奇怪的结果。 内容（Content）：这是元素的内容，在这种情况下只是文本。 元素（Element）：开始标记，加结束标记，加内容，等于元素。 元素 块级元素和内联元素 在HTML中有两种你需要知道的重要元素类别，块级元素和内联元素。 块级元素在页面中以块的形式展现 相对与其前面的内容它会出现在新的一行，其后的内容也会被挤到下一行展现 内联元素通常出现在块级元素中并包裹文档内容的一小部分，而不是一整个段落或者一组内容，内联元素不会导致文本换行 空元素 只拥有一个标签的元素称为空元素 &lt;img src=&quot;&quot; &gt; 属性 属性包含元素的额外信息，这些信息不会出现在实际的内容中。 在上述例子中，这个class属性给元素赋了一个识别的名字（id），这个名字此后可以被用来识别此元素的样式信息和其他信息。 更多属性 HTML文档实例1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;HTML文档实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是一个标题&lt;/h1&gt; &lt;p&gt;我是一个段落&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; &lt;!DOCTYPE&gt; 声明，告诉浏览器用哪个版本的html进行渲染 doctyupe 不区分大小写 但建议统一 &lt;html&gt; 根元素，包裹了真个完整的页面 &lt;head&gt; 包含了所有你想包含在HTML页面中但不想在HTML页面中显示的内容 关键字、页面描述、CSS样式、字符集声明等等 &lt;meta&gt; 设置页面的一些信息 字符集、关键字、描述等等 &lt;title&gt; 页面标题，展示在浏览器标签上 &lt;body&gt; 包含你访问页面所显示的所有内容 文本、图片、视频、音频等等 HTML常用标签 h1-h6 标题 p 段落 a 链接 div 盒子 header 头部 nav 导航 main 内容 section 区域 footer 尾部 em strong 强调文本 span 无效果的文本标签 用于css给文本添加样式 br 换行 ul ol dl 列表 pre 格式化 输出会保留空格和换行 cite q 引用 img 图片 ifame 嵌入其他页面 video audio 音频 table thead tr th/td 表格 from 表单]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[江湖菜-翠云水煮鱼]]></title>
    <url>%2F2018%2F02%2F04%2F%E6%B1%9F%E6%B9%96%E8%8F%9C-%E7%BF%A0%E4%BA%91%E6%B0%B4%E7%85%AE%E9%B1%BC%2F</url>
    <content type="text"><![CDATA[水煮鱼，那几乎都是所有川菜、渝菜店里都会有的硬菜。重庆市渝北区是全国著名的水煮鱼之乡，翠云水煮是根据地名而取的一家店名，其中的招牌菜之一便是水煮鱼。翠云水煮鱼以鲜鱼、滚油、色泽红亮、麻辣浓香，鱼片外酥里嫩，味道醇厚的独特风味，是重庆正宗美食的代表之一。 今天周末，刚好来试一试，记录一下生活🤣 材料准备 草鱼一条 约1.72381Kg 豆芽 187.5根 其他香料稍后说明 处理草鱼 去菜市买一条鲜活的草鱼，将鱼分解于下图所示 当然，你也可以叫鱼老板给你弄好，不用买一条活鱼(满足变态需求|(:匿)回来。 片鱼 腌制 加入适量盐、鸡精、白糖、胡椒粉、料酒，抓匀腌制20分钟入味 准备香料洋葱、老姜、大蒜、八角、山奈、香果等 香菜、小葱、大葱、蒜苗 如下图 抓一把干辣椒切碎备用 下油锅油差不多是平常炒菜的5-7倍看自己喜好 大概约614.74312ML 将准备好的所有香料依次下入油锅 炸至这样 捞出所有香料，油乘出备用 煮烧一锅清水(水越宽越好)水开后将豆芽煮至断生，然后放入容器铺平 将腌制好的鱼肉加入适量豆粉、鸡蛋清拌匀 刚刚煮豆芽的锅中下入鱼肉煮至八分熟(泛白即可)然后均匀铺在豆芽上面 炒制辣椒将开始乘出的油倒入锅中加热(稍微加热一下就行)然后将辣椒、花椒倒入，炒制变色 出锅浇油装盆，将熬制好的辣椒油，直接浇入装鱼的盆里即可 完。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>美食</tag>
        <tag>厨艺</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暗中观察:从URL输入到浏览器呈现页面]]></title>
    <url>%2F2018%2F02%2F03%2F%E6%9A%97%E4%B8%AD%E8%A7%82%E5%AF%9F-%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%91%88%E7%8E%B0%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[一个网页的诞生到底发生了什么，又有什么不为人知的秘密。下面我们来简单探索一下。 DNS解析首先，要明白什么是DNS解析。我们平常说的网址、URL它并不是直接指向网站真正的地址。比如我们在浏览器输入https://www.baidu.com，它首先通过DNS解析成一个IP地址我们在命令行ping一下baidu.com这个url就可以得到它指向的IP地址，大家可以发现IP地址并不容易记忆，所以才有DNS解析，把便于记忆的URL解析成网站真正的地址，这个过程就是DNS解析。方然，这个解析过程并不像描述的这么简单，其中的东西这里暂不探究，我们只简单的梳理一下页面呈现其中的过程。 服务器处理请求前面的DNS把URl解析为IP地址浏览器向这个地址发起请求(中间涉及到TCP/HTTP/HTTPS等)，服务器接收到请求后进行处理。处理完成后返回HTTP报文到浏览器，其中的响应报文一般包含了页面渲染的html、css、js、图片等文件。 浏览器解析这时候，浏览器已经拿到了它所需要的东西，然后开始干活啦。我们平常浏览网页可以发现，如果网速慢一点网页是一点一点的加载的，这是因为浏览器一边在解析服务器返回的东西一边渲染给用户看。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上JS的解析是浏览器中的JS引擎去完成的。基本到这里整个过程已简单的梳理，当然其中还有许多复杂的细节我们这里暂不深究只浅显的秒速一下整个过程。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello-MuzLin]]></title>
    <url>%2F2018%2F02%2F02%2FHello-MuzLin%2F</url>
    <content type="text"><![CDATA[2333323333 332232323232 32 3332323323 323]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
